mondc

compiler generates executable
mond-
pre -> lexer -> parser -> optimizer -> linker -> codegen
compiler generates assembly

--------------------------------------------------------------------------------

file names:

test.mon

-> pre
test.monp

-> rest of compiler
test.s (assembly)

--------------------------------------------------------------------------------

what can a file contain?

1. macros

2. global variables

3. functions

4. classes

5. models

--------------------------------------------------------------------------------

(global) variables

- begin with global
- in scope of every class or function, even if imported by other file
- mustn't be initiated
- can't be static
- can be "public" for accessibility in files imported by
- can be "con" for becoming a constant
- syntax:

global [public] (type) nameofvariable;
global [con] [public] (type) nameofvariable = 5;

--------------------------------------------------------------------------------

pointers

- outside of classes: global variables
- inside of classes: fields or local variables
- ptr keyword used
- act as a own datatype having a type itself
- syntax:

string ptr variableorfieldname = otherstring;

variableorfieldname = &otherstring;
variableorfieldname => otherstring

- "variablename" gives the memory location of the stored "otherstring"
- the dereference operator "*" gives with "*variablename" the value it points to
- the ampersand operator "&" gives with "&variablename" the own memory location.

-     -     -     -     -     -     -     -     -     -     -     -     -     -

function pointers

- outside of classes: global variables
- inside of classes: fields or local variables

for example:

int funcptr functionname(int a, int b);

functionname => otherfunction;
functionname = &otherfunction;

- can be assigned to a function returning an int and taking 2 ints as an argument
after assignment the function the pointer points to can be called via the
dereference operator

*functionname(2, 3);

function pointers can't call the referenced function without dereferencing

"functioname" gives the memory address of the function it points to
"&functionname" gives the memory address of the pointer
"*functionname(2, 3)" acts as a full function

- these are the same:

void funcptr functionname(int a, int b);
funcptr functionname(int a, int b);

- dereference before calling
*functionname(int a, int b);

-     -     -     -     -     -     -     -     -     -     -     -     -     -

flex pointers

- needs to be type casted before dereference
- syntax:

flexptr variable = &someint;
int thisint = *((int)variable);

variable = &somestring;
string thisstring = *((string)variable);

- type casting doesn't change the type of the variable itself, but the type they
point to

--------------------------------------------------------------------------------

functions

- don't begin with global (scope irrelevant, purpose for functional language)
- can't be static
- can be "public" for accessibility in files imported by
- syntax:

[public] int functionname() {
  return 0;
}

an example for a void-function without access mods:

void functionname() {

}

functionname() {

}

- both declarations are the same since giving no return type indicates "void"

- arguments are listed like

functionname(int arg1, string arg2){}

the function "functionname" cant be used for assigning operations, but the bare
name without the function parameters can be used for getting assigned to
function pointers or getting the own memory location via the ampersand operator.

- contain control structures, create and assign variables / fields and call
other functions

--------------------------------------------------------------------------------

lambda

- can't be void

returntype lambda variablename = (int arg1, int arg2) -> (arg1 * arg2);

--------------------------------------------------------------------------------

arrays

- fixed size data collection
- items accessible by [] with it's index starting on 0
- negative numbers are used to get the last items
- arrays automatically create a basepointer with it's name like this:

int[] testvariable = [1,2,3];

- arrays can also be created by ranges:

- an array is also created by putting [] behind a type:

int[3] testvariable;

- or multidimensional (3x3) (array of array of int)

int[3][3] testvariable;

- for pointers:

int[3] ptr testvariable;

  pointer to int-array, int-array on dereference

int ptr[3] testvariable;

  array of pointers, int of dereference of item

int[3] ptr[3] testvariable;

  array of pointers, int-array of dereference of item
  e.g. *(testvariable[0])[1] gets the 1st pointer, gets an int-array by
  dereference and applys [1] to get the second int

- instanciation works like this:

int[3] testvariable = [1,2,3];

  created a int[] array (array of with 3 elements);

- testvariable now can't be assigned to a array bigger or smaller than this

- arrays can also be created via the "range" notation

int[] testvariable = [0..4,1];

- the first number is the starting number, the number after it is the last
- it can also be written like this:

[..4,1]

- since no starting number uses the default number 0
- and the ",1" can also be removed because the default step is 1;

[..4]

- ranges are supported for all integers and floating-point-types
- technically the range is constructed until the "<= 4" in this examples
isn't met anymore

--------------------------------------------------------------------------------

classes

[public] [classtype] class classname {}

- can be public to get imported by other files

- may contain following things:
    - fields and special fields
    - methods and special methods
    - memberclasses and membermodels

- may extend classes via inheritance
- may implement models

- classtypes for normal classes can be:
    - con (can't get extended)
    - blank (blank classes have own rules)

-     -     -     -     -     -     -     -     -     -    -    -    -     -   -

fields

- can be static
- have accessmods
- need type

[accessmod] (type) fieldname;
[accessmod] int fieldname = 5;

-    -     -     -      -     -     -     -     -       -      -      -      -

methods

- "functions" which are defined in classes as members
- can be static
- have accessmods

[accessmod] [static] (returntype) functionname() {}

- returntype can be "void" or nothing indicating a void type

- contain control structures, create and assign variables / fields and call
other functions

-   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -

special fields and special methods

$ : references "this", pointer to this object

$init() : constructor, can have accessmods
$deinit() : deconstructor, can have accessmods
$old() : used in methods that get overridden, same params, same returntype

$main()
$main(string[] args) : main function, can also be outside of class,
                        automatically public, static and void

-   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -

memberclasses

- class definition in other class
- is automatically "static":
    - in outerclass, accessed by "memberclass"
    - outside of outerclass, accessed by "outerclass.memberclass"


[accessmod] [classtype] class classname {}

- may contain following things:
    - fields and special fields
    - methods and special methods
    - memberclasses
    - enums

- may extend classes via inheritance
- may implement models

- classtypes for normal classes can be:
    - con (constant classes can't get extended)
    - blank (blank classes have own rules)

--------------------------------------------------------------------------------

blank classes

- classes with the keyword "blank"
- can't have private fields / methods
- can have non-blank methods
- can extend any non-constant class
- can't get instanciated
- blank classes implementing models don't need to implement model methods
- syntax:

blank class classname{}

-     -     -     -     -     -     -     -     -     -     -     -     -     -

blank methods

- begin with the keyword "blank"
- don't have code to execute; blank methods
- can't be private
- syntax:

blank [accessmods] (returntype) functionname(int arg);

--------------------------------------------------------------------------------

models

- java like interface
- can implement other models
- can be public to get imported by other files
- can only consist of blank methods
- syntax:

[public] model modelname {

}

- blank methods must be implemented by implementing class

-     -     -     -     -     -     -     -     -     -     -     -     -     -

membermodels

- model definition in other class
- is automatically "static":
    - in outerclass, accessed by "membermodel"
    - outside of outerclass, accessed by "outerclass.membermodel"
- can have any access mods

[accessmod] model modelname {

}

--------------------------------------------------------------------------------

(class/function/method/field) templates

<?a, ?b, ?c> ?c functionname(?a x, ?b y) {

}

functionname<int, int, int>(3,4);

- compiler creates for every function/class/method/field/global-variable
  creation a single copy with concrete classes replacing the placeholders

- placeholders begin with a "?"

class exampleclass<?a, ?b, ?c> {}

- inside of this class, the placeholders don't need to be redefined like in
functions.

- placeholders can be fixed to a superclass:

<?a : superclassname>

- placeholders can be fixed to a class implementing a model:

<?a ++ modelname>

--------------------------------------------------------------------------------

constructing, deconstructing, inline constructing, accessing fields TODO

--------------------------------------------------------------------------------

access-modifier

- following accessmods are available:

family    = accessible in this class, inherited, import not accessible
public    = accessible outside of scope, import accessible

- global variables are private by default
- functions are private by default
- classes / models are private by default
- fields / methods / memberclasses / membermodels are private by default
- blank methods are public by default, can't be private

--------------------------------------------------------------------------------

inheritance, implementing models, "override"

class exampleclass : superclass ++ model1, model2<int>, model3 {}

- static methods aren't inherited

- exampleclass gets the public / family fields and methods of superclass
- exampleclass gets all blank methods from models and abstract superclass,
they must've get overridden

- syntax for override with calling old supermethod:

override [oldaccessmod] (oldreturntype) oldfunctionname() {
  return $old();
}

--------------------------------------------------------------------------------

type casting

- normal pointers can't be type casted
- arrays can't be type casted, only on it's items
- flex pointers change the type pointed to if cast before dereferencing
- basic casting can be applied to datatypes
- up- and downcasting can be applied to objects and their base / superclass
- syntax:

int x = (int) 3.14f; (basic casting)

flexptr x = someint;
int ptr someintpointer = ((int)flexptr); (needed for flexptr)

Derived d = Derived();
Base b = (Base) d; (downcast)

Base b = Base();
Derived d = (Derived) b; (upcast)


--------------------------------------------------------------------------------

guess (automatically assigning types)

- keyword "guess" instead of a class or datatype is possible in:

- variables or fields on assignment, not initializing or assigning "null"
- function/method return types, guessing the return type and using that

--------------------------------------------------------------------------------

control structures TODO

begin (objectclass object = objectclass()) {}

  - automatically executes "delete object" after


error handling; try-catch

  try {
    //do something...
    Exception obj = Exception("message");
    throw obj;
  } catch(Exception x) {
    //do something with x
  }

  - "throw" is an operator
  - the standard library defines the class "Exception" for adequate use
  - catch then defines an object and casts it's type onto the thrown object:

  Exception x = (Exception) thrownobj; (theoretical first line in catch block)

--------------------------------------------------------------------------------

datatypes TODO

basics

  byte      1         0xff  20    0b11111111
  word      2         0xffff  232 0b1111111111111111
  int       4         123   0xFF  0b10101010
  dint      8         123   0xFF  0b10101010
  qint      16        123   0xFF  0b10101010
  float     4         1.23f
  double    8         2.5432
  char      1         'a'  '\n' 123 255
  unichar   2         u'x'  500
  bool      1 bit     true false 1 0
  void      0         only for functions

compounds

  string
  unistring
  array

specials

  lambda
  ptr
  funcptr
  flexptr


--------------------------------------------------------------------------------

operator support for classes

- with the keyword "operator" classes can implement operator support for
special operators capable of doing so

- syntax:

operator returnclass operatorname() {
  return null;
}

- operators cannot be created by believes, the implementations follow strict
rules

--------------------------------------------------------------------------------

operators TODO

special-operators

  non overridable

  1. delete operator - delete

      delete variable;
      calls variable.$deinit() if object, frees memory

  2. throw operator - throw

      throw variable;
      if variable is null, terminates, otherwise gets passed onto catch-block in
      try-catch

-     -     -     -     -     -     -     -     -     -     -     -     -     -

meta-operators

  non overridable, evaluated during compilation

  1. spaceof operator -  spaceof

      (spaceof variable)
      produces int, the size the variable occupies in bytes

  2. instanceof operator - instanceof

      (variable instanceof classname)
      produces boolean, if variable is object of classname or inherits from it

  3. typeof operator - typeof

      (typeof variable)
      produces the type (class or datatype) of variable

-     -     -     -     -     -     -     -     -     -     -     -     -     -

--------------------------------------------------------------------------------


Preprocessor "mondpre"

- processes macros
- e.g. merges files
- imports "standard" library with public, global functions

-     -     -     -     -     -     -     -     -     -     -     -     -     -

macros

- begin with %
- syntax: %macroname arg1, arg2 (...);
- get processed before compilation by "mondpre"

current normal macros:
%import onlinerepo;
%include localfile.mon;
%nostandard;                    (tells mondpre to not include standardlib)

-     -     -     -     -     -     -     -     -     -     -     -     -     -

special macros

1. getter / setter / xetter

  %getter typename, fieldname;
  %getter accessmod, typename, fieldname;

    if accessmod not given, public by default,
    generates getter-method; replaces given macro with the following code:

    (accessmod) typename get_fieldname() {
      return $.fieldname;
    }

  %setter typename, fieldname;
  %setter accessmod, typename, fieldname;

    if accessmod not given, public by default,
    generates setter-method; replaces given macro with the following code:

    (accessmod) void set_fieldname(typename a) {
      $.fieldname = a;
    }

  %xetter typename, fieldname;
  %xetter accessmod, typename, fieldname;

    this is replaced by both %setter and %getter with the same arguments,
    creates getters and setters

  %getter fieldname;

    this is replaced by "%getter (typeof fieldname), fieldname"

  %setter fieldname;

    this is replaced by "%setter (typeof fieldname), fieldname"

  %xetter fieldname;

    this is replaced by "%xetter (typeof fieldname), fieldname"

--------------------------------------------------------------------------------

Lexer

--------------------------------------------------------------------------------

future "cool" features

c function calls by including c libs
libbus (called by "mondpre") handles imports via online repos
