{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome this page will be used to document the mond language visit language-docs Synopsis \"mond\" is a general-purpose, partially object oriented, partially functional system programming language. The main goal is not to mix syntax of different languages by personal likes / dislikes, but furthermore to create a language that lets the programmer choose the way he uses mond by himself. Therefore, a use for user-level applications shouldn't restrict hardware-bound, low-level operations. \"You get what you pay for.\" Goals In the first dev-stage, the compiler \"mondc\" and it's subparts are built. If everything goes as planned, mond gets improved, e.g. external support of other languages, (dynamically) linked libraries or executables introduced. In the third stage, important libraries are created and after that more complex, case related libraries designed.","title":"Welcome"},{"location":"#welcome","text":"this page will be used to document the mond language visit language-docs","title":"Welcome"},{"location":"#synopsis","text":"\"mond\" is a general-purpose, partially object oriented, partially functional system programming language. The main goal is not to mix syntax of different languages by personal likes / dislikes, but furthermore to create a language that lets the programmer choose the way he uses mond by himself. Therefore, a use for user-level applications shouldn't restrict hardware-bound, low-level operations. \"You get what you pay for.\"","title":"Synopsis"},{"location":"#goals","text":"In the first dev-stage, the compiler \"mondc\" and it's subparts are built. If everything goes as planned, mond gets improved, e.g. external support of other languages, (dynamically) linked libraries or executables introduced. In the third stage, important libraries are created and after that more complex, case related libraries designed.","title":"Goals"},{"location":"Language/Compiler/compiler/","text":"mondc starts with mondpre","title":"mondc"},{"location":"Language/Compiler/compiler/#mondc","text":"starts with mondpre","title":"mondc"},{"location":"Language/Use/Errors/","text":"Errors Thrown in compilation-time. Not the same as Exceptions in the std lib.","title":"Errors"},{"location":"Language/Use/Errors/#errors","text":"Thrown in compilation-time. Not the same as Exceptions in the std lib.","title":"Errors"},{"location":"Language/Use/casting/","text":"","title":"Casting"},{"location":"Language/Use/controlstructures/","text":"","title":"Controlstructures"},{"location":"Language/Use/globalvars/","text":"Global variables Variables outside of any function, class or other scopes are considered to be global. They begin with the glob keyword: glob int variable; glob char somechar = '\\n'; Global variables behave like normal variables; they can be assigned to anything or declared on definition. reassignment outside of functions is not possible. Global variables can be constant by using con . glob con int CONSTANT_X = 10;","title":"Global variables"},{"location":"Language/Use/globalvars/#global-variables","text":"Variables outside of any function, class or other scopes are considered to be global. They begin with the glob keyword: glob int variable; glob char somechar = '\\n'; Global variables behave like normal variables; they can be assigned to anything or declared on definition. reassignment outside of functions is not possible. Global variables can be constant by using con . glob con int CONSTANT_X = 10;","title":"Global variables"},{"location":"Language/Use/grammar/","text":"Grammar","title":"Grammar"},{"location":"Language/Use/grammar/#grammar","text":"","title":"Grammar"},{"location":"Language/Use/mon/","text":".mon File The file-extension for mond-files is .mon . A file can contain the following things: Macros Global variables Functions Classes Models","title":".mon File"},{"location":"Language/Use/mon/#mon-file","text":"The file-extension for mond-files is .mon . A file can contain the following things: Macros Global variables Functions Classes Models","title":".mon File"},{"location":"Language/Use/operators/","text":"","title":"Operators"},{"location":"Language/Use/philosophy/","text":"","title":"Philosophy"},{"location":"Language/Use/templates/","text":"","title":"Templates"},{"location":"Language/Use/Macros/flags/","text":"Predefined Flags The preprocessor can predefine the following flags to give compiler-, os-, or cpu-architecture-dependent information: _OS_WIN64 _OS_WIN32 _OS_LINUX _OS_UNIX _OS_MAC","title":"Predefined Flags"},{"location":"Language/Use/Macros/flags/#predefined-flags","text":"The preprocessor can predefine the following flags to give compiler-, os-, or cpu-architecture-dependent information: _OS_WIN64 _OS_WIN32 _OS_LINUX _OS_UNIX _OS_MAC","title":"Predefined Flags"},{"location":"Language/Use/Macros/macros/","text":"Macros mondpre (first compiler part) preprocesses macros. They aren't recognized by any language specifications. The macro operator is % . How to call a macro: %incl file.mon; %getter char, somechar; Macro-Usage The macroname incl or getter need to be directly after the % . The arguments are separated by a comma and parsed without space-characters into a wordlist. For arguments containing spaces string, semicolons or the macro operator, literals are introduced: %incl \"folder with space/file.mon\"; %incl \"folder;with%special signs/file.mon\"; NOTE: Using backslashes to write characters is not possible! backslashes are still parsed as the c-like syntax '\\'. 1. Include ( %incl ) includes given directory into the .mon file. takes 1 argument to determine relative file path %incl file/path.mon; 2. Flag ( %flag ) sets a preprocessor flag; saves given string for later preprocessing (e.g. flag-request). takes 1 argument, the flag string: %incl _CUSTOM_FLAG; flag names are _UPPER_SNAKE_CASE by convention, but they can be any string. 3. Flag-Request ( %isset ) produces a boolean value ( true , false ) whether a flag is currently defined or not. takes 1 argument, the flag string: %isset _CUSTOM_FLAG; 4. Getter ( %getter ) produces a getter function get_name() , while name being the given argument; can take up to 3 arguments, the first being a access-modifier, the second one the type of the field given as the third argument. If argument 1 isn't given, then argument 1 is the type. if only one argument is used, it's the variable. %getter public, int, someint; %getter int, someint; %getter someint; # everything produces: public int get_someint() { return $.someint; } int get_someint() { return $.someint; } (typeof someint) get_someint() { return $.someint; } 4. Setter ( %setter ) works the same as %getter , produces setter function set_name() %setter public, int, someint; %setter int, someint; %setter someint; # everything produces: public void set_someint(int x) { $someint = x; } void set_someint(int x) { $someint = x; } void set_someint((typeof someint) x) { $someint = x; } 4. Xetter ( %xetter ) works the same as %getter and %setter , produces both getter function get_name() and setter function set_name() . %xetter public, int, someint; %xetter int, someint; %xetter someint;","title":"Macros"},{"location":"Language/Use/Macros/macros/#macros","text":"mondpre (first compiler part) preprocesses macros. They aren't recognized by any language specifications. The macro operator is % . How to call a macro: %incl file.mon; %getter char, somechar;","title":"Macros"},{"location":"Language/Use/Macros/macros/#macro-usage","text":"The macroname incl or getter need to be directly after the % . The arguments are separated by a comma and parsed without space-characters into a wordlist. For arguments containing spaces string, semicolons or the macro operator, literals are introduced: %incl \"folder with space/file.mon\"; %incl \"folder;with%special signs/file.mon\"; NOTE: Using backslashes to write characters is not possible! backslashes are still parsed as the c-like syntax '\\'.","title":"Macro-Usage"},{"location":"Language/Use/Macros/macros/#1-include-incl","text":"includes given directory into the .mon file. takes 1 argument to determine relative file path %incl file/path.mon;","title":"1. Include (%incl)"},{"location":"Language/Use/Macros/macros/#2-flag-flag","text":"sets a preprocessor flag; saves given string for later preprocessing (e.g. flag-request). takes 1 argument, the flag string: %incl _CUSTOM_FLAG; flag names are _UPPER_SNAKE_CASE by convention, but they can be any string.","title":"2. Flag (%flag)"},{"location":"Language/Use/Macros/macros/#3-flag-request-isset","text":"produces a boolean value ( true , false ) whether a flag is currently defined or not. takes 1 argument, the flag string: %isset _CUSTOM_FLAG;","title":"3. Flag-Request (%isset)"},{"location":"Language/Use/Macros/macros/#4-getter-getter","text":"produces a getter function get_name() , while name being the given argument; can take up to 3 arguments, the first being a access-modifier, the second one the type of the field given as the third argument. If argument 1 isn't given, then argument 1 is the type. if only one argument is used, it's the variable. %getter public, int, someint; %getter int, someint; %getter someint; # everything produces: public int get_someint() { return $.someint; } int get_someint() { return $.someint; } (typeof someint) get_someint() { return $.someint; }","title":"4. Getter (%getter)"},{"location":"Language/Use/Macros/macros/#4-setter-setter","text":"works the same as %getter , produces setter function set_name() %setter public, int, someint; %setter int, someint; %setter someint; # everything produces: public void set_someint(int x) { $someint = x; } void set_someint(int x) { $someint = x; } void set_someint((typeof someint) x) { $someint = x; }","title":"4. Setter (%setter)"},{"location":"Language/Use/Macros/macros/#4-xetter-xetter","text":"works the same as %getter and %setter , produces both getter function get_name() and setter function set_name() . %xetter public, int, someint; %xetter int, someint; %xetter someint;","title":"4. Xetter (%xetter)"},{"location":"Language/Use/Macros/models/","text":"","title":"Models"},{"location":"Language/Use/STD/Exceptions/","text":"","title":"Exceptions"},{"location":"Language/Use/STD/std/","text":"","title":"Std"},{"location":"Language/Use/Types/classes/","text":"Classes class name {} Classes contain the following things: fields methods and predefined methods memberclasses and membermodels A class' predefined methods are it's constructor $init and it's deconstructor $deinit . class x { int y; $init(int y) { $.y = y; } } x myobj = x(5); # -> myobj.y gives 5 On delete , the class' deconstructor $deinit gets called. A reference to the class itself is accessed by the predefined literal $ . An object (class instance) is created via: class car {} car somecar = car(); Calling the constructor car() allocates space and returns a new object. A class may be of a special type: con (can't get extended) abstract static con class x {} class y : x {} # ILLEGAL Classes can have one superclass and implement as many models as they want. Abstract classes / Undefined methods Abstract classes begin with the abstract keyword: abstract class x {} All fields and methods within this type of class are of the family access modifier. Abstract classes can inherit and implement other classes and models like normal. Besides that, abstract classes are able to have undefined method s. Undefined methods don't have a code block and need to be overridden by it's derived class. abstract class x { void function(int arg); } class y : x { override void function(int arg) {} } Static classes A static class can't be constructed, it's fields and methods behave like normal functions and variables but under the scope of a class: static class x{ void func() {} } x.func(); Inheritance Inheritance enables a class to get fields and methods from it's superclass. class derived : base {} The : literal indicates inheritance. Only public and family fields and methods get inherited; Values without an access-modifier aren't accessible but theoretically existing in memory. Memberclasses & Membermodels Memberclasses and membermodels are classes/models defined in the scope of other classes. It doesn't matter if the wrapping class is static or not; the memberclass / -model is accessed via the wrapping class' name. Because of that, memberclasses aren't fields or methods of classes, they are just normal classes with an additional class in it's name. class outer { class inner {} } outer.inner myobj = outer.inner(); If the wrapping class is static the memberclass / -model can access it's fields and methods. Because memberclasses / -models are defined within other classes, they can have access-modifier. class outer { model m1 {} # only visible here family model m2 {} # only visible here and for subclasses public model m3 {} # visible everywhere } Memberclasses can be static , abstract and con aswell. Implementing Models Since models enable classes to poly-implement them, a implemented field or method must be accessed via the model, the member operator . and the name of the field/method. Models can be implemented via ++ : model m1 { int somefield; void x(); } model m2 {} class y ++ m1, m2 { override void m1.x(){ m1.somefield = 10; } } Access-Modifier Override Operator-Support","title":"Classes"},{"location":"Language/Use/Types/classes/#classes","text":"class name {} Classes contain the following things: fields methods and predefined methods memberclasses and membermodels A class' predefined methods are it's constructor $init and it's deconstructor $deinit . class x { int y; $init(int y) { $.y = y; } } x myobj = x(5); # -> myobj.y gives 5 On delete , the class' deconstructor $deinit gets called. A reference to the class itself is accessed by the predefined literal $ . An object (class instance) is created via: class car {} car somecar = car(); Calling the constructor car() allocates space and returns a new object. A class may be of a special type: con (can't get extended) abstract static con class x {} class y : x {} # ILLEGAL Classes can have one superclass and implement as many models as they want.","title":"Classes"},{"location":"Language/Use/Types/classes/#abstract-classes-undefined-methods","text":"Abstract classes begin with the abstract keyword: abstract class x {} All fields and methods within this type of class are of the family access modifier. Abstract classes can inherit and implement other classes and models like normal. Besides that, abstract classes are able to have undefined method s. Undefined methods don't have a code block and need to be overridden by it's derived class. abstract class x { void function(int arg); } class y : x { override void function(int arg) {} }","title":"Abstract classes / Undefined methods"},{"location":"Language/Use/Types/classes/#static-classes","text":"A static class can't be constructed, it's fields and methods behave like normal functions and variables but under the scope of a class: static class x{ void func() {} } x.func();","title":"Static classes"},{"location":"Language/Use/Types/classes/#inheritance","text":"Inheritance enables a class to get fields and methods from it's superclass. class derived : base {} The : literal indicates inheritance. Only public and family fields and methods get inherited; Values without an access-modifier aren't accessible but theoretically existing in memory.","title":"Inheritance"},{"location":"Language/Use/Types/classes/#memberclasses-membermodels","text":"Memberclasses and membermodels are classes/models defined in the scope of other classes. It doesn't matter if the wrapping class is static or not; the memberclass / -model is accessed via the wrapping class' name. Because of that, memberclasses aren't fields or methods of classes, they are just normal classes with an additional class in it's name. class outer { class inner {} } outer.inner myobj = outer.inner(); If the wrapping class is static the memberclass / -model can access it's fields and methods. Because memberclasses / -models are defined within other classes, they can have access-modifier. class outer { model m1 {} # only visible here family model m2 {} # only visible here and for subclasses public model m3 {} # visible everywhere } Memberclasses can be static , abstract and con aswell.","title":"Memberclasses &amp; Membermodels"},{"location":"Language/Use/Types/classes/#implementing-models","text":"Since models enable classes to poly-implement them, a implemented field or method must be accessed via the model, the member operator . and the name of the field/method. Models can be implemented via ++ : model m1 { int somefield; void x(); } model m2 {} class y ++ m1, m2 { override void m1.x(){ m1.somefield = 10; } }","title":"Implementing Models"},{"location":"Language/Use/Types/classes/#access-modifier","text":"","title":"Access-Modifier"},{"location":"Language/Use/Types/classes/#override","text":"","title":"Override"},{"location":"Language/Use/Types/classes/#operator-support","text":"","title":"Operator-Support"},{"location":"Language/Use/Types/functions/","text":"Functions Functions may take arguments, may compute by using control structurs, may do other operations and may return a value. Functions need to have a return type. Giving no return type results in void : void somefunction() {} # is the same as somefunction() {} Arguments are listed in the function-call operator () , separated by a comma: int somefunction(int arg1, string arg2) { return 0; } a function is identical if all three conditions are given: Same name Same return type Same argument types in the same order Functions can't be reassigned, they can only be assigned to pointers without the function-call operator () . Return values Functions can return any of the following types: any datatype ( basic & compounds ) flexptr ptr funcptr void any object s of a defined class the syntax for the special datatypes is always the same; imagine declaring a variable and appending the function-call operator () and a code block via {} : flexptr myfunc1() {...} string ptr myfunc2() {...} int funcptr myfunc3(string, string)(int arg2, int arg3) {...} void funcptr myfunc4()() {...} int[] myfunc5() {...} myfunc2 returns a pointer to the string type. myfunc3 returns a functionpointer which returns an int and takes two string s. myfunc3 itself takes two int s as argument. myfunc4 returns a functionpointer to a void-function both returning and taking nothing. myfunc1 and myfunc5 are self-explanatory. If the function being pointed by the function pointer returned by myfunc3 wants to be called, use this: *(myfunc3(1,2))(\"string1\", \"string2\"); here myfunc3(1,2) returns the function pointer, which needs to be dereferenced before using the function-call operator () with the arguments of two strings. Arguments Function-arguments behave the same way like declaring a variable. Function pointers for example can be arguments like this: void myfunc(void funcptr arg1(int, int)) {} arg1 is a function pointer to a void-function taking two integers as arguments. To separate call-by-value and call-by-reference, con is used to determine that a value passed as an argument is copied and wouldn't change the passed argument itself. void myfunc(con int arg1, int arg2) {} here arg1 can be changed, but the passed variable isn't changed, only it's value copied into arg1 . Inline functions Functions can be defined in functions, meaning these inline functions can only be called inside it's defined scope. void outerfunction() { void innerfunc() {} innerfunc(); } inline functions can also be returned as funcptr s pointed to them. Lambda-Syntax The classic syntax of int myfunc(int i) {return i + 2;} can be transformed into int myfunc(int i) -> (i+2); . This is for functions only having a return statement, not computing other things such as bare, void function calls or control structures. The syntax can be seen as the following pseudocode: type name(type1 arg1, type2 arg) -> (returnstatement); Undefined-(Method)-Syntax Methods in Models or sometimes in abstract classes need to be undefined, which means that no code-block is defined: abstract class x{ void y(); } class z : x{ override void y() {} } Note: This only occurs in classes","title":"Functions"},{"location":"Language/Use/Types/functions/#functions","text":"Functions may take arguments, may compute by using control structurs, may do other operations and may return a value. Functions need to have a return type. Giving no return type results in void : void somefunction() {} # is the same as somefunction() {} Arguments are listed in the function-call operator () , separated by a comma: int somefunction(int arg1, string arg2) { return 0; } a function is identical if all three conditions are given: Same name Same return type Same argument types in the same order Functions can't be reassigned, they can only be assigned to pointers without the function-call operator () .","title":"Functions"},{"location":"Language/Use/Types/functions/#return-values","text":"Functions can return any of the following types: any datatype ( basic & compounds ) flexptr ptr funcptr void any object s of a defined class the syntax for the special datatypes is always the same; imagine declaring a variable and appending the function-call operator () and a code block via {} : flexptr myfunc1() {...} string ptr myfunc2() {...} int funcptr myfunc3(string, string)(int arg2, int arg3) {...} void funcptr myfunc4()() {...} int[] myfunc5() {...} myfunc2 returns a pointer to the string type. myfunc3 returns a functionpointer which returns an int and takes two string s. myfunc3 itself takes two int s as argument. myfunc4 returns a functionpointer to a void-function both returning and taking nothing. myfunc1 and myfunc5 are self-explanatory. If the function being pointed by the function pointer returned by myfunc3 wants to be called, use this: *(myfunc3(1,2))(\"string1\", \"string2\"); here myfunc3(1,2) returns the function pointer, which needs to be dereferenced before using the function-call operator () with the arguments of two strings.","title":"Return values"},{"location":"Language/Use/Types/functions/#arguments","text":"Function-arguments behave the same way like declaring a variable. Function pointers for example can be arguments like this: void myfunc(void funcptr arg1(int, int)) {} arg1 is a function pointer to a void-function taking two integers as arguments. To separate call-by-value and call-by-reference, con is used to determine that a value passed as an argument is copied and wouldn't change the passed argument itself. void myfunc(con int arg1, int arg2) {} here arg1 can be changed, but the passed variable isn't changed, only it's value copied into arg1 .","title":"Arguments"},{"location":"Language/Use/Types/functions/#inline-functions","text":"Functions can be defined in functions, meaning these inline functions can only be called inside it's defined scope. void outerfunction() { void innerfunc() {} innerfunc(); } inline functions can also be returned as funcptr s pointed to them.","title":"Inline functions"},{"location":"Language/Use/Types/functions/#lambda-syntax","text":"The classic syntax of int myfunc(int i) {return i + 2;} can be transformed into int myfunc(int i) -> (i+2); . This is for functions only having a return statement, not computing other things such as bare, void function calls or control structures. The syntax can be seen as the following pseudocode: type name(type1 arg1, type2 arg) -> (returnstatement);","title":"Lambda-Syntax"},{"location":"Language/Use/Types/functions/#undefined-method-syntax","text":"Methods in Models or sometimes in abstract classes need to be undefined, which means that no code-block is defined: abstract class x{ void y(); } class z : x{ override void y() {} } Note: This only occurs in classes","title":"Undefined-(Method)-Syntax"},{"location":"Language/Use/Types/models/","text":"Models model m {} Models can be compared to \"interfaces\" in Java. They contain fields and undefined Methods, which are functions without code-blocks, that need to be overridden by the class implementing those. Models can be implemented via ++ : model m1 { int somefield; void x(); } model m2 {} class y ++ m1, m2 { override void m1.x(){ m1.somefield = 10; } }","title":"Models"},{"location":"Language/Use/Types/models/#models","text":"model m {} Models can be compared to \"interfaces\" in Java. They contain fields and undefined Methods, which are functions without code-blocks, that need to be overridden by the class implementing those. Models can be implemented via ++ : model m1 { int somefield; void x(); } model m2 {} class y ++ m1, m2 { override void m1.x(){ m1.somefield = 10; } }","title":"Models"},{"location":"Language/Use/Types/typeguessing/","text":"","title":"Typeguessing"},{"location":"Language/Use/Types/Datatypes/Basic/bools/","text":"","title":"Bools"},{"location":"Language/Use/Types/Datatypes/Basic/chars/","text":"","title":"Chars"},{"location":"Language/Use/Types/Datatypes/Basic/floatings/","text":"","title":"Floatings"},{"location":"Language/Use/Types/Datatypes/Basic/integer/","text":"","title":"Integer"},{"location":"Language/Use/Types/Datatypes/Compound/arrays/","text":"Arrays An array is a fixed-size, linear list of elements of the same type. Items of the array are accessible via the subscript operator [] with it's first element at index 0. If the index in the subscript is negative, counting begins at the and of the array. Writing [] after a type declares the array type: int[3] myarray; Array declarations need a given length. If the array is assigned on declaration, this length isn't needed; the array-length is the same as the value being assigned to it: int[] myarray = function_returning_int_array(); int[] myarray2 = [1,2,3,4]; An array-value begins with the start of the list [ , its items separated by a comma and the end of the list ] . Ranges Arrays can also be created via a range . Ranges are a specific notation to create an array: int[] myarray = r[1..10,2]; The syntax r[start..end,increment] creates a list starting at start with the last value being end while incrementing start always by the increment number. A Range can also be r[..10] if no increment or startvalue is chosen. Then, the start value is 0 and the increment 1 by default.","title":"Arrays"},{"location":"Language/Use/Types/Datatypes/Compound/arrays/#arrays","text":"An array is a fixed-size, linear list of elements of the same type. Items of the array are accessible via the subscript operator [] with it's first element at index 0. If the index in the subscript is negative, counting begins at the and of the array. Writing [] after a type declares the array type: int[3] myarray; Array declarations need a given length. If the array is assigned on declaration, this length isn't needed; the array-length is the same as the value being assigned to it: int[] myarray = function_returning_int_array(); int[] myarray2 = [1,2,3,4]; An array-value begins with the start of the list [ , its items separated by a comma and the end of the list ] .","title":"Arrays"},{"location":"Language/Use/Types/Datatypes/Compound/arrays/#ranges","text":"Arrays can also be created via a range . Ranges are a specific notation to create an array: int[] myarray = r[1..10,2]; The syntax r[start..end,increment] creates a list starting at start with the last value being end while incrementing start always by the increment number. A Range can also be r[..10] if no increment or startvalue is chosen. Then, the start value is 0 and the increment 1 by default.","title":"Ranges"},{"location":"Language/Use/Types/Datatypes/Compound/strings/","text":"Strings A string belongs to the compound datatypes and are a sequence of char s ending with the null character \\0 . Strings are enclosed with \" signs. string x = \"test\"; Enclosing a variable's value in strings can be done by using {} in a string with the variable's name in it: string x = \"hello\"; string y = \"{x} world!\"; # -> \"hello world!\" To access a char within the string, use the subscript operator [] : string x = \"hello\"; char y = x[1]; # y = 'e'; Negative indices mean that the counting begins at the end of the string, e.g. x[-1] being 'o' . strings can contain backslashed characters for e.g. non-writable characters such as the newline \\\\n : string x = \"hello\\nworld!\"; strings can be concatenated via the add operator + : string x = \"hello \" + \"world!\"; or multiplied ( * ) with an int : string x = \"hello\" * 3; # -> \"hellohellohello\" or at the end subtracted with an int via the sub operator - : string x = \"hello\" - 2; # -> \"hel\" Unicode-strings A ustring is technically the same as a string , but contains wide uchar characters. Unicode-string literals must start with an u : ustring x = u\"hello\";","title":"Strings"},{"location":"Language/Use/Types/Datatypes/Compound/strings/#strings","text":"A string belongs to the compound datatypes and are a sequence of char s ending with the null character \\0 . Strings are enclosed with \" signs. string x = \"test\"; Enclosing a variable's value in strings can be done by using {} in a string with the variable's name in it: string x = \"hello\"; string y = \"{x} world!\"; # -> \"hello world!\" To access a char within the string, use the subscript operator [] : string x = \"hello\"; char y = x[1]; # y = 'e'; Negative indices mean that the counting begins at the end of the string, e.g. x[-1] being 'o' . strings can contain backslashed characters for e.g. non-writable characters such as the newline \\\\n : string x = \"hello\\nworld!\"; strings can be concatenated via the add operator + : string x = \"hello \" + \"world!\"; or multiplied ( * ) with an int : string x = \"hello\" * 3; # -> \"hellohellohello\" or at the end subtracted with an int via the sub operator - : string x = \"hello\" - 2; # -> \"hel\"","title":"Strings"},{"location":"Language/Use/Types/Datatypes/Compound/strings/#unicode-strings","text":"A ustring is technically the same as a string , but contains wide uchar characters. Unicode-string literals must start with an u : ustring x = u\"hello\";","title":"Unicode-strings"},{"location":"Language/Use/Types/Datatypes/Special/flexpointers/","text":"Flex(-ible) pointers The flexptr belongs to the special datatypes . It behaves the same way a normal ptr does, but without a declared type being pointed to. This allows the pointer C-like \"void pointer\" behaviour. flexptr variable = &someint; variable = &somechar; before dereferencing, the pointer needs to be casted to a type: flexptr variable = &somechar; char somechar = *((char) variable); typecasting a flexptr doesn't change the type of the variable from flexptr to the given type; it only changes the type being pointed to.","title":"Flex(-ible) pointers"},{"location":"Language/Use/Types/Datatypes/Special/flexpointers/#flex-ible-pointers","text":"The flexptr belongs to the special datatypes . It behaves the same way a normal ptr does, but without a declared type being pointed to. This allows the pointer C-like \"void pointer\" behaviour. flexptr variable = &someint; variable = &somechar; before dereferencing, the pointer needs to be casted to a type: flexptr variable = &somechar; char somechar = *((char) variable); typecasting a flexptr doesn't change the type of the variable from flexptr to the given type; it only changes the type being pointed to.","title":"Flex(-ible) pointers"},{"location":"Language/Use/Types/Datatypes/Special/funcpointers/","text":"Function pointers Function pointers belong to the special datatypes as well as the pointers. For them the funcptr keyword is used. Special information is needed on definition: string funcptr myfptr(string, string); A function pointer has a fixed return-type and set of arguments. Declaring Argument-names would be wrong. The example function can now point to any function returning the string type whilst taking two string arguments. Like pointers, The function can be assigned directly to other pointers, by the \"points-to\" operator => to a value/variable or without but \"ampersand'd\". dereferencing the function pointer leads to a function call: myfptr => somefunc; *myfptr(\"test\", \"abc\"); Function pointers can also be void and not giving a returntype results in void . void funcptr myptr(); # is the same as funcptr myptr();","title":"Function pointers"},{"location":"Language/Use/Types/Datatypes/Special/funcpointers/#function-pointers","text":"Function pointers belong to the special datatypes as well as the pointers. For them the funcptr keyword is used. Special information is needed on definition: string funcptr myfptr(string, string); A function pointer has a fixed return-type and set of arguments. Declaring Argument-names would be wrong. The example function can now point to any function returning the string type whilst taking two string arguments. Like pointers, The function can be assigned directly to other pointers, by the \"points-to\" operator => to a value/variable or without but \"ampersand'd\". dereferencing the function pointer leads to a function call: myfptr => somefunc; *myfptr(\"test\", \"abc\"); Function pointers can also be void and not giving a returntype results in void . void funcptr myptr(); # is the same as funcptr myptr();","title":"Function pointers"},{"location":"Language/Use/Types/Datatypes/Special/objects/","text":"","title":"Objects"},{"location":"Language/Use/Types/Datatypes/Special/pointers/","text":"Pointers The pointer type belongs to the special datatypes , having extra operators and syntax. A normal pointer's size is 8 bytes and only points to a memory location where a single value is stored. Objects and variables of datatypes but not functions. They can point to other function pointers. The ptr keyword defines pointers: string ptr ptrvar; A pointer needs to have it's type named before. Leaving the type blank doesn't initiate a C-like \"void\" pointer. Pointers can be assigned to other pointers, meaning they point to the same location. ptrvar = otherstringptr; Besides that, they are assigned to memory locations of other variables / values via the ampersand operator & . ptrvar = &somestring; If there is no personal favour in getting the memory location at first, the \"pointing-to\" operator => can be used: ptrvar => somestring; The dereference operator * allows to get the value of the memory location it's being pointed on. C-like dereferencing on assignment is not possible, but this is: ptrvar = otherstringptr; # is the same as ptrvar => *otherstringptr;","title":"Pointers"},{"location":"Language/Use/Types/Datatypes/Special/pointers/#pointers","text":"The pointer type belongs to the special datatypes , having extra operators and syntax. A normal pointer's size is 8 bytes and only points to a memory location where a single value is stored. Objects and variables of datatypes but not functions. They can point to other function pointers. The ptr keyword defines pointers: string ptr ptrvar; A pointer needs to have it's type named before. Leaving the type blank doesn't initiate a C-like \"void\" pointer. Pointers can be assigned to other pointers, meaning they point to the same location. ptrvar = otherstringptr; Besides that, they are assigned to memory locations of other variables / values via the ampersand operator & . ptrvar = &somestring; If there is no personal favour in getting the memory location at first, the \"pointing-to\" operator => can be used: ptrvar => somestring; The dereference operator * allows to get the value of the memory location it's being pointed on. C-like dereferencing on assignment is not possible, but this is: ptrvar = otherstringptr; # is the same as ptrvar => *otherstringptr;","title":"Pointers"}]}